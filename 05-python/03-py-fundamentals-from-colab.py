# -*- coding: utf-8 -*-
"""3-Python Fundamentals from Colab.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PktDb263x2mKzG4RTREc4OIwSTXOHFWK

## Intro to python fundamentals
"""

# Four key types
a = 1 # int (Integers, whole numbers)
type(a) # recall in R: typeof()

b = 0.25 # float ("double", numeric, real numbers)
type(b)

c = 'Berlin' # str (string, "character", object)
type(c)

d = True # bool (Boolean, binary, "logical", True/False)
type(d)

"""**Exercise 3.1**

What will these commands produce
"""

1 + 1

'1' + '1'

"""In the above command we "added" two strings together "concatenate". In R, we would use `paste()`"""

'1' * 5

"""prediction: error because you're "adding" a `str` with `int`. Or... 11111, or `15`."""

'1' '1'

"""## Exploring Functions & Methods

First initialize some packages
"""

import math # literally from math import *
import numpy as np
import pandas as pd
from scipy import stats
from scipy.stats import ttest_ind
from statsmodels.stats.multicomp import pairwise_tukeyhsd
from statsmodels.formula.api import ols

"""Call some basic functions"""

numb = 8
np.log2(numb)

math.log2(8)

"""### Lists (Data containers I)

This give an error :/ `can only concatenate list (not "int") to list`
"""

# [1, 6, 9, 36] + 100

"""Below, we may predict `11,106,19,136` if we expect vector recycling (as in R,), but what we really get is ... `1,6,9,36,10,100`"""

[1, 6, 9, 36] + [10, 100]

"""Below we'll get the same thing"""

[1, 6, 9, 36] + [100, 200, 300, 400]

[1, 6, 9, 36] + [100, "dogs", 300, 400]

"""This shows us that lists can be _heterogeneous_"""

heights = [167, 188, 178, 194, 171, 169]
heights

type(heights)

np.mean(heights) # the mean

np.std(heights) # the standard deviation

sum(heights)

len(heights) # The number of elements, would use length()

"""**Exercise 3.3**

 Calculate the lower and upper limits of the 95% confidence interval for the list of heights.
"""

# Lower limit: mean - 1.96 * sd/sqrt of n
heights_mean = np.mean(heights)
height_sd = np.std(heights)
height_sq_n = math.sqrt(len(heights))

heights_mean - 1.96 * height_sd/height_sq_n

# Upper limit: mean + 1.96 * sd/sqrt of n

heights_mean + 1.96 * height_sd/height_sq_n

"""**Exercise 3.4**

Using the data below:
"""

cities = ['Munich', 'Paris', 'Amsterdam', 'Madrid', 'Istanbul']
dist = [584, 1054, 653, 2301, 2191]

"""- How many observations are there?"""

len(dist)

"""- What is the longest and shortest distance?"""

# longest
max(dist)

# shortest
min(dist)

"""- Get the average distance"""

np.mean(dist)
# sum(dist)/len(dist)

"""**Exercise 3.5** 

Visualize the values in the `dist` list as a _univariate strip plot_ or a _histogram_.
"""

# First import seaborn to get nice plotting functions
# use the alias sns
import seaborn as sns
sns.histplot(dist)

sns.stripplot(dist)

"""### Making functions

Use the `def` keyword to _define_ a new function `addNumbs` whidh will take two arguments `x` and `y` and uses the `return` keyword to give back the result. Add a comment using `'''` notation.
"""

def addNumbs(x, y):
    """Add two numbers together"""
    z = x + y
    return z

addNumbs(5, 6)

"""**Exercise 3.6** 
Create a function, `confInt` that** takes a list **and returns the lower 95%CI limit
"""

def confInt(x):
    """Calculate the 95%CI"""
    m = np.mean(x)
    std = np.std(x)
    n = len(x)
    CiH = m + 1.96 * std / math.sqrt(n)
    CiL = m - 1.96 * std / math.sqrt(n)
    return CiL

confInt(heights)

"""Outputting more than one value as a **tuple**"""

def mathFun(x, y):
    """Add and subtract two numbers together"""
    return x + y, x - y

my_out = mathFun(4, 6)
type(my_out)

"""**Exercise 3.7** 
Create a tuple output from `confInt` that returns the lower & upper 95%CI limit
"""

def confInt(x):
    """Calculate the 95%CI"""
    m = np.mean(x)
    std = np.std(x)
    n = len(x)
    CiH = m + 1.96 * std / math.sqrt(n)
    CiL = m - 1.96 * std / math.sqrt(n)
    return CiL, CiH

confInt(heights)

"""**lamba** functions: Making _anonymous_ functions.

A simple syntax for making short and simple functions:
"""

raise_to_power =  lambda x, y: x ** y
raise_to_power(2, 3)

"""More typically, a way to make unnamed _anonymous_ functions:"""

nums = [3, 5, 6, 8, 3]
nums # a list of 5 elements

# nums ** 2 # this gives a typeError :/ :/ we would actually expect vector recycling

square_all = map(lambda num: num ** 2, nums) # this applies a lamba functions to each element and outputs a map objects

list(square_all) # this converts to a list object

"""### Methods

Methods are special functions that belong to specific objects.
"""

l = [1, "2", True]
l

# l can be directly modified
l.append("append value")

# Not:
# l = append(l, "appended value")
# This would be similar to c(l, "value") in R

l

# lower() converts but does not update this scalar
name = "Berlin"
name.lower()

name.upper()

cities

# lower() is not a method for a list object
# cities.lower()

"""Methods for numerical list objects"""

# Available methods for this object:
dir(dist)

"""Examples:

- `.append()`
"""

# Append a new value to the end of the list:
dist.append(500)

dist

"""- `.clear`"""

# Remove all items
dist.clear()

dist

# Re-establish dist
dist = [584, 1054, 653, 2301, 2191, 500]
dist

"""- `copy`"""

# Makes a shallow copy (we'll see this later on)
# dist.copy()

"""- `count`"""

dist.count(653)

"""- `extend`"""

# Need an iterable object here:
# dist.extend()

"""- `index`"""

# First index position of a value
dist.index(1054) #1, since python indexes from 0

"""- `insert`"""

dist.insert(1, 999)
dist

"""- `pop`"""

dist.pop(4)

dist

"""- `remove`"""

dist.remove(999)

dist

"""- `reverse`"""

dist.reverse()
dist

"""- `sort`"""

dist.sort()
dist

"""#### A short aside on Coercion"""

type(numb)

str(numb)

# Still an integer
numb

letter = '8'
type(letter)

int(letter)

"""### Attribues

The `__` notation is pronounced _dunder_ (double underscore)
"""

l.__len__

# This accesses the attribute directly
len(l)

"""Recall our function from earlier, with `'''`"""

addNumbs.__doc__

"""### Dictionaries

- `[]` produce lists
- `()` produce tuples (immutable)
- `{}` produce dictionaries `key:value`
- `dict(zip([],[]))` zip two lists to make a dictionary
"""

d = {'int_value':3, 
     'bool_value':False, 
     'str_value':'hello'}

d

# basic indexing using a key
d['str_value'] #return the value at this key position

"""Adding more `values` using lists."""

organizations = {'name': ['Volkswagen', 'Daimler', 'Allianz', 'Charite'],
                 'structure': ['company', 'company', 'company', 'research']}

organizations

organizations['name']

"""Create a dictionary from two lists using zip()"""

heights = [167, 188, 178, 194, 171, 169]
persons = ["Mary", "John", "Kevin", "Elena", "Doug", "Galin"]

heights_persons = dict(zip(persons, heights))
heights_persons

# what if we remove one:
heights = [167, 188, 178, 194, 171, 169]
persons = ["Mary", "Kevin", "Elena", "Doug", "Galin"]

heights_persons_2 = dict(zip(persons, heights))
heights_persons_2
# last value is unmatched and exempted

heights_persons.keys()

heights_persons.values()

"""**Exercise 3.16**"""

cities = ['Munich', 'Paris', 'Amsterdam', 'Madrid', 'Istanbul']
dist = [584, 1054, 653, 2301, 2191]

distDict = dict(zip(cities, dist))
distDict

"""## NumPy (Data Containers III)

- np.array([]) produces an ndarray

**bold text**`ndarray` where nd = n-dimensional array.
"""

# already imported nympy as np
# Basic list
xx = [3, 8, 9, 23]
xx

xx = np.array([3, 8, 9, 23])
xx

# wide variety of items, i.e. a list of lists
yy = np.array([[5,7,8,9,3], 
          [0,3,6,8,2],
          range(5)])
yy

# Recall: a list and an integer

my_list = [1, 6, 9, 36]

# error
# my_list + 100

# append a value to a list
my_list + [100]

my_array = np.array(my_list)

# Broadcasting (Vector recycling) :) :)
my_array + 100

type(my_array)

"""## DataFrames with Pandas (Data Containers IV)

- `pd.DataFrame({})` produces a DataFrame from a dictionary
- `pd.DataFrame(dict(list(zip([],[]))))` produces a DataFrame from a list of names and list of lists
"""

foo1 = [True, False, False, True, True, False]
foo2 = ["Liver", "Brain", "Testes", "Muscle", "Intestine", "Heart"]
foo3 = [13, 88, 1233, 55, 233, 18]

# We have already imported pandas as pd
# use a dictionary to get a data frame
foo_df = pd.DataFrame({'healthy': foo1, 
                       'tissue': foo2, 
                       'quantity': foo3})

foo_df

"""**Exercise 4.1**"""

distDictDF = pd.DataFrame({"City": cities,
                           "Distance": dist})
distDictDF

"""#### From Lists (jsut as an example)"""

# names
list_names = ['healthy', 'tissue', 'quantity']

# columns are a list of lists
list_cols = [foo1, foo2, foo3]
list_cols

zip_list = list(zip(list_names, list_cols))
zip_list

zip_dict = dict(zip_list)
zip_dict # True dictionary

zip_df = pd.DataFrame(zip_dict)
zip_df

"""### Working with DataFrames"""

foo_df['healthy'] #indexing by name, an individual column "Series", 1-dim array

foo_df[['healthy']] # DataFrame with 1 column

foo_df.healthy # Get the Series using a `.` notation

# Add a new column and populate it with the value (which is recycled, i.e. "broadcast" over the length of the Series)
foo_df['new'] = 0
foo_df

# But this doesn't work
foo_df.new2 = 4
foo_df

"""# Mini-case study - exercise 4.8"""

import pandas as pd
mtcars = pd.read_csv('data/mtcars.csv')
mtcars.head()

"""1. Calculate the correlation between `mpg` and `wt` and test if it is significant."""

# corr() is not a function:
# corr(mtcars['mpg'], mtcars['wt'])

# A correlation matrix
cor_mat = mtcars.corr()
cor_mat[['wt']].iloc[0]

# Targeted correlation between two Series in the DataFrame
mtcars['mpg'].corr(mtcars['wt'])

# Using NumPy
r = np.corrcoef(mtcars['mpg'], mtcars['wt'])
r

# import pingouin as pg 
# pg.corr(x=mtcars['mpg'], y=mtcars['wt'])

import scipy.stats as stats
stats.pearsonr(mtcars['mpg'], mtcars['wt'])

"""2. Visualize the relationship in an XY scatter plot (bonus points for a regression line)."""

# previously imported seaborn (see above)
# sns.scatter(x=mtcars['mpg'], y=mtcars['wt'])

import matplotlib.pyplot as plt # Low level plotting
y = mtcars.mpg
x = mtcars.wt
plt.scatter(x,y)
# plt.show()

sns.regplot(x="wt", y="mpg", data = mtcars, ci=None)

sns.lmplot(x="wt", y="mpg", data=mtcars, ci=None)

# from sklearn.linear_model import LinearRegression
# model = LinearRegression().fit(x, y)

from statsmodels.formula.api import ols
model = ols("mpg ~ wt", data=mtcars)
results = model.fit()
results.summary()

"""For plotting:

- Continuous vs continuous (i.e. scatter plot), but also
- Continuous vs categorical, or 
- Categorical vs continuous

**Y-Axis**
- Dependent variable (i.e. _dependent_ on the indpendent variable)
- Response (i.e. the _outcome_)
- f(x) (i.e. y _as a function of_ x)

**X-Axis**
- Independent variable (i.e. decided upon by the experimenter)
- Predictor (a variable that _predicts_ a specific resonse, i.e. y)

3. Convert `wt` column from pounds to kg (bouns points for adding it to the DataFrame).
"""

# Avoid making unnecessary new objects that are separate from your DataFrame
#twocol = mtcars[['mpg','wt']]
#twocol['kilo'] = y/2.2046
#twocol

mtcars["wt"]

mtcars["wt"].apply(lambda x: x/2.2046)

mtcars['wt_kg'] = mtcars['wt']/2.2046226218

# Alternatvely:
# mtcars['wt_kg_2'] = mtcars['wt']*0.453592

"""# Indexing"""

foo_df

foo_df['tissue']

foo_df[['tissue']]

foo_df.tissue

"""index position as number with `.iloc[]`"""

# First row, as a Series
foo_df.iloc[0]

# First row, as a DataFrame
foo_df.iloc[[0]]

foo_df.iloc[[0, 1]]

"""Using two dimensions:"""

# To get all columns, use : after the comma
foo_df.iloc[0,:] # : == everything

# Valid
# foo_df.iloc[0,]

"""Indexing begins at 0 and is _exclusive_"""

# The first two columns, all rows
foo_df.iloc[:,:2] # 0, 1, and exclude 2

# One column as a Series
foo_df.iloc[:,1]

# The same, as a DataFrame
foo_df.iloc[:,1:2]

# counting from the opposite direction
# -1 is the last row
foo_df.iloc[-1,]
# forward: 0  1  2  3  4  5
# Reverse -6 -5 -4 -3 -2 -1

foo_df

foo_df.reverse()

"""**Exercise 5.1**

Using foo_df, retreive:

The 2nd to 3rd rows
"""

# foo_df.iloc[2:3, :] # only the 3rd row
# foo_df.iloc[[2,3],:] # the 3rd & the 4th row using a list
# foo_df.iloc[2:4] # the 3rd & the 4th row using : notation
# foo_df.iloc[0:2,] # 1st & 2nd rows
# foo_df[-1:2,:] # Computer says "no"
# foo_df.iloc[3:,:] # 4th to the end 

# yes :)
# foo_df.iloc[[1, 2]] # 2nd & 3rd rows using a list
# foo_df.iloc[1:3,:] # 2nd & 3rd rows using : notation

"""The last 2 rows"""

foo_df[-2:]

# The last two no matter how long
foo_df.iloc[-2:]
# foo_df.iloc[[-1,-2],:] # specify the order with a list

# Hard coding positions
# foo_df.iloc[ [4, 5],:]
# foo_df.iloc[4:,:]

"""A random row in foo_df"""

# import random
# foo_df.iloc[[random.randrange(0, len(foo_df))]]
foo_df.sample()

"""From the 4th to the last row
(But without hard-coding, i.e. regardless of how many rows my data frame contains)
"""

# foo_df[3:]
foo_df.iloc[3:,:]

"""** Exercise 5.2**

Using `.iloc()` with:
"""

# Integers? yes :)
foo_df.iloc[4,]

# Floats? Computer says no
# foo_df[0.1:]

# Strings (Characters)? Computer says "no"
# foo_df.iloc[:,'tissue']
# foo_df.iloc['Brain'] # need to look inside the tissue column
# foo_df.iloc['A'] # No is no 'A' anyways
# foo_df[heart:]   # No object defined

# A heterogenous list? Computer says "no"
# foo_df.iloc[:,[1, 'quantity']]

# A homogenous list?
foo_df.iloc[[1,4,-1,-1,3,2,0]]

"""**Exercise 5.3**

Use indexing to obtain all the odd rows
"""

foo_df.iloc[1::2] # 2nd, 4th, 6th

foo_df.iloc[lambda x: x.index % 2 == 1]

foo_df[foo_df.index % 2 != 0]

"""Use indexing to obtain all the even rows"""

foo_df.iloc[::2] # 1st, 3rd, 5th

foo_df.iloc[lambda x: x.index % 2 == 0]

"""# Logical Expressions

Relational and logical operators
"""

foo_df[foo_df.quantity >= 233]

foo_df[(foo_df.tissue == "Heart") | (foo_df.quantity >= 233)]

"""**Exercise 5.4**

Only “healthy” samples.
"""

foo_df[foo_df.healthy]

"""Only “unhealthy” samples."""

foo_df[-foo_df.healthy]

foo_df[~foo_df.healthy]

"""**Exercise 5.5**

Only low quantity samples, those below 100.
"""



"""Midrange: Quantity between 100 and 1000,"""



"""Tails of the distribution: Quantity below 100 and beyond 1000."""



"""**Exercise 5.6**

Only “Heart” samples.
"""



"""“Heart” and “liver” samples"""



"""Everything except “intestines”"""

